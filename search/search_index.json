{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-ethereumnix","title":"What is Ethereum.nix?","text":"<p>Ethereum.nix is a collection of Nix packages and NixOS modules designed to make it easier to operate Ethereum related services and infrastructure.</p> <p>For the uninitiated, using Ethereum.nix will give you the following benefits:</p> <ul> <li>Access to a wide range of Ethereum applications packaged with Nix, ready to run without fuss. Nix guarantees you don't have to worry about version conflicts, missing dependencies or even what state your OS is in.</li> <li>We aim that every Ethereum application stored in the repository is constructed from its source, including all input dependencies. This approach guarantees the code's reproducibility and trustworthiness. Furthermore, with Nix, expert users can tweak and adjust the build process to any degree of detail as required.</li> <li>We develop custom NixOS modules to streamline operations with applications such as Execution and Consensus clients (including performing backups). Moreover, we aim to introduce further abstractions that simplify everyday tasks, such as running a production grade Liquid Staking deployment or even a local development environment for running consensus clients and execution clients effortlessly without needing Docker or Kubernetes.</li> </ul> <p>This project is developed entirely in Nix Flakes (but it offers compatibility with legacy Nix thanks to <code>flake-compat</code>).</p>"},{"location":"#eager-to-use-ethereumnix","title":"Eager to use Ethereum.nix?","text":"<p> New to Ethereum.nix and Nix?</p> <p> Get started by installing Nix on your system and how to use it with Ethereum.nix  Getting Started  </p> <p> Want to use an application now?</p> <p> See our list of supported applications ready to be used in seconds.  See supported Applications  </p> <p> Want to run Ethereum services on NixOS?</p> <p> Run Ethereum services easily with our supported NixOS modules.  Run Ethereum services on NixOS  </p> <p> Have a question or need help?</p> <p> Ask questions on our discussion board and get in touch with our community.  Ask a question </p>"},{"location":"#about-the-project","title":"About the project","text":"<p>In the beginning Ethereum.nix was a playground for Aldo Borrero to experiment with nix'ifying Ethereum related processes. Since then, the project got accepted by the Nix Community incubator program and it has a grown into an ever-increasing number of packages and modules targeted towards streamlining day-to-day operations across a variety of different projects.</p> <p>Aldo Borrero</p><p>Creator of Ethereum.nix   Full Stack freak! Blockchain passionate! </p> <p>Brian McGee</p><p>Maintainer of Ethereum.nix   Writer of software \u2022 Lover of craft beer </p> <p>Sergey Yakovlev</p><p>Maintainer of Ethereum.nix   Love Nix, Rust, Ethereum | SRE </p>"},{"location":"#comercial-support","title":"Comercial Support?","text":"<p>Are you seeking to use Ethereum.nix effectively within your organization for Blockchain related projects?</p> <p>Below you can see the list of companies that offers support to Ethereum.nix, Nix and NixOS ecosystem:</p>"},{"location":"#numtide","title":"Numtide","text":"<p>Numtide is a team of independent freelancers that love open source. We help our customers make their project lifecycles more efficient by:</p> <ul> <li>Providing and supporting useful tools such as this one.</li> <li>Building and deploying infrastructure, and offering dedicated DevOps support.</li> <li>Building their in-house Nix skills, and integrating Nix with their workflows.</li> <li>Developing additional features and tools.</li> <li>Carrying out custom research and development.</li> <li>In the case of Blockchain building resilient systems and infrastructure to MEV services.</li> </ul> <p>Contact us if you have a project in mind, or if you need help with any of our supported tools, including this one. We'd love to hear from you.</p>"},{"location":"apps/","title":"Apps","text":"<p>The list of supported apps is growing every day! We plan to keep this list up to date, but, if we have missed any, please let us know!</p> <p>Note</p> <p>Every command has a local and a remote variant. The local variant requires that the command is run from within the cloned repo. The remote variant can be run from wherever.</p> <ul> <li>Local: <code>nix run .#my-app-name</code></li> <li>Remote: <code>nix run github:nix-community/ethereum.nix#my-app-name</code></li> </ul> <p>For brevity and consistency, all the commands are listed in the local variant.</p>"},{"location":"apps/#consenus-clients","title":"Consenus Clients","text":"<p>The consensus client (also known as the Beacon Node, CL client or formerly the Eth2 client) implements the proof-of-stake consensus algorithm, which enables the network to achieve agreement based on validated data from the execution client.</p> App Command Lighthouse <code>nix run .#lighthouse</code> Lodestar Not supported yet. Prysm <code>nix run .#prysm-beacon-chain</code> <code>nix run .#prysm-validator</code> <code>nix run .#prysm-validator</code> <code>nix run .#prysm-client-stats</code> <code>nix run .#prysm-prysmctl</code> Teku <code>nix run .#teku</code> Nimbus <code>nix run .#teku</code>"},{"location":"apps/#execution-clients","title":"Execution Clients","text":"<p>The execution client (also known as the Execution Engine, EL client or formerly the Eth1 client) listens to new transactions broadcasted in the network, executes them in EVM, and holds the latest state and database of all current Ethereum data.</p> App Command Besu <code>nix run .#besu</code> Erigon <code>nix run .#erigon</code> Geth <code>nix run .#geth</code> <code>nix run .#geth-abidump</code> <code>nix run .#geth-abigen</code> <code>nix run .#geth-bootnode</code> <code>nix run .#geth-clef</code> <code>nix run .#geth-devp2p</code> <code>nix run .#geth-ethky</code> <code>nix run .#geth-evm</code> <code>nix run .#geth-faucet</code> <code>nix run .#geth-rlpdump</code> Nethermind <code>nix run .#nethermind-runner</code> <code>nix run .#nethermind</code>"},{"location":"apps/#dvt-distributed-validator-technology","title":"DVT (Distributed Validator Technology)","text":"<p>Distributed validator technology (DVT) is an approach to validator security that spreads out key management and signing responsibilities across multiple parties, to reduce single points of failure, and increase validator resiliency.</p> App Command Charon <code>nix run .#charon</code> SSVNode <code>nix run .#ssvnode</code>"},{"location":"apps/#editors","title":"Editors","text":""},{"location":"apps/#visual-studio-code-vscode","title":"Visual Studio Code (VSCode)","text":"<p>The following extensions are supported:</p> Extension Command VSCode Solidity Auditor Not available. Tools for Solidity Not available."},{"location":"apps/#mev-maximal-extractable-value","title":"MEV (Maximal Extractable Value)","text":"<p>Maximal extractable value (MEV) refers to the maximum value that can be extracted from block production in excess of the standard block reward and gas fees by including, excluding, and changing the order of transactions in a block.</p> App Command Dreamboat <code>nix run .#dreamboat</code> mev-boost <code>nix run .#mev-boost</code> mev-boost-builder <code>nix run .#mev-boost-builder</code> mev-boost-prysm <code>nix run .#mev-boost-prysm</code> mev-boost-relay <code>nix run .#mev-boost-relay</code> mev-rs <code>nix run .#mev</code>"},{"location":"apps/#signers","title":"Signers","text":"App Command Dirk <code>nix run .#dirk</code> web3signer <code>nix run .#erigon</code>"},{"location":"apps/#utils","title":"Utils","text":"<p>Utilities and applications can't be categorized into any category of the above.</p> App Command eth2-testnet-genesis <code>nix run .#eth2-testnet-genesis</code> ethdo <code>nix run .#ethdo</code> ethereal <code>nix run .#ethereal</code> sedge <code>nix run .#sedge</code> staking-deposit-cli <code>nix run .#deposit</code> zcli <code>nix run .#zcli</code>"},{"location":"apps/#validators","title":"Validators","text":"<p>Standalone validators clients.</p> App Command Vouch <code>nix run .#vouch</code>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome! It's great to see that you're interested in Nix and also in Ethereum.nix. These installation instructions are intended to have a basic installation of Nix on your system ready to be used alongside Ethereum.nix.</p> <p>Of course, if you're a seasoned Nix user, these installation instructions can be safely skipped (as you probably know what you're doing!).</p> What is exactly Nix? <p>Some people might need clarification on what exactly is Nix. To clarify:</p> <ul> <li>Nix is a cross-platform package manager that utilizes a purely functional deployment model where software is installed into unique directories generated through cryptographic hashes.</li> <li>Nix is also the name of the tool's programming language.</li> <li>NixOS is a Linux distribution based on the Nix package manager.</li> </ul> <p>We recommend you have a look at the following sources to get yourself familiar with the Nix ecosystem and mechanics first before starting with Ethereum.nix:</p> <ul> <li>Zero to Nix: A well-written guide with insightful information about using Nix and several important concepts.</li> <li>Nix Reference Manual: This is a more comprenhensive guide (and also more notoriosly difficult) about Nix.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Nix, the package manager, can be installed quite easily using the official installation script. We have left the installation instructions here for your convenience1. Still, we recommend looking at the official source should you have more questions or want to customize the installation experience.</p>"},{"location":"getting-started/#on-non-nix-systems-linux-macos-windows-wsl2-docker","title":"On non-Nix systems (Linux, MacOS, Windows WSL2, Docker)","text":"<p>For some systems, there are two installation methods:</p> <ul> <li>Multi user (always recommended).</li> <li>Single user.</li> </ul> Which type of installation should you choose? Multi-user or Single user? <p>This depends on your requirements, but here is a short list of reasons why it's recommended the multi-user installation:</p> <p>Pros:</p> <ul> <li>Better build isolation (and that is what Nix is all about).</li> <li>Better security (a build can not write somewhere in your home).</li> <li>Sharing builds between users.</li> </ul> <p>Cons:</p> <ul> <li>Requires root to run the daemon.</li> <li>More involved installation (creation of <code>nixbld*</code> users, installing a systemd unit, ...).</li> <li>Harder to uninstall.</li> </ul> <p>To run the installer:</p> <code>Linux - Multi-user installation (recommended)</code> <code>Linux - Single user installation</code> <code>macOS</code> <code>Windows WSL2 - Multi-user installation</code> <code>Windows WSL2 - Single user installation</code> <code>Docker</code> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon\n</code></pre> <p>Info</p> <p>We recommend the multi-user install if you are on Linux running systemd, with SELinux disabled and you can authenticate with <code>sudo</code>.</p> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --no-daemon\n</code></pre> <p>Info</p> <p>Above command will perform a single-user installation of Nix, meaning that <code>/nix</code> is owned by the invoking user. You should run this under your usual user account, not as <code>root</code>. The script will invoke sudo to create <code>/nix</code> if it doesn\u2019t already exist.</p> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon\n</code></pre> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon\n</code></pre> <p>Info</p> <p>WSL versions 0.67.6 and above have systemd support. Follow Microsoft's systemd guide to configure it, and then install Nix using</p> <pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --no-daemon\n</code></pre> <p>Start a Docker shell with Nix:</p> <pre><code>docker run -it nixos/nix\n</code></pre> <p>Or start a Docker shell with Nix exposing a <code>workdir</code> directory:</p> <pre><code>mkdir workdir\ndocker run -it -v $(pwd)/workdir:/workdir nixos/nix\n</code></pre> <p>Open a new terminal session, and the nix executable should be in your <code>$PATH</code>. To verify that:</p> <pre><code>nix --version\n</code></pre> <p>This should print the version information for Nix.</p>"},{"location":"getting-started/#on-nixos","title":"On NixOS","text":"<p>If you're running NixOS, you don't need to install Nix, as it's already included!  </p>"},{"location":"getting-started/#enable-flakes-support","title":"Enable Flakes Support","text":"<p>Make sure Nix Flakes functionality is enabled to ease your operations when using Ethereum.nix. </p> <p>Are not Nix Flakes experimental?</p> <p>Nix flakes are still in the experimental stage within Nix, and there's no defined timeline for their official launch. While we don't expect significant changes to the user interface for flakes during the experimental phase, there could still be some minor changes.s.</p> <p>We believe that enabling Flakes is the best form of learning Nix for those new to the ecosystem.</p>"},{"location":"getting-started/#on-non-nix-systems-linux-macos-windows-wsl2-docker_1","title":"On non-Nix systems (Linux, MacOS, Windows WSL2, Docker)","text":"<p>Edit (or create) either <code>~/.config/nix/nix.conf</code> or <code>/etc/nix/nix.conf</code> and add the following entry:</p> <pre><code>experimental-features = nix-command flakes\n</code></pre> <p>If the Nix installation is in multi-user mode, don\u2019t forget to restart the <code>nix-daemon</code>.</p> <p>To verify that Nix flakes are enabled just type the following on the terminal:</p> <pre><code>nix show-config | grep flakes\n</code></pre> <p>It should display what we already wrote on the config file:</p> <pre><code>experimental-features = flakes nix-command\n</code></pre>"},{"location":"getting-started/#on-nixos_1","title":"On NixOS","text":"<p>To do so, edit your <code>configuration.nix</code> and add the following:</p> <code>configuration.nix</code> <pre><code>{ pkgs, ... }: {\n  nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n}\n</code></pre> <p>And rebuild your system closure! That's it!</p>"},{"location":"getting-started/#add-ethereumnix-to-your-flake-registry","title":"Add Ethereum.nix to your Flake registry","text":"<p>When dealing with Ethereum.nix, we can use of flakes registries. Flake registries are a convenience feature that allows you to refer to flakes using symbolic identifiers such as <code>nixpkgs</code>, rather than full URLs such as <code>git://github.com/NixOS/nixpkgs</code>. You can use these identifiers on the command line (e.g. when you do <code>nix run nixpkgs#hello</code>) or in flake input specifications in <code>flake.nix</code> files.</p> <p>If you're curious, you can list all registries that are available in your system with the following command:</p> <pre><code>nix registry list\n</code></pre> <p>We do recommend adding Ethereum.nix to your flake registry. To do so:</p> <pre><code>nix registry add enix github:nix-community/ethereum.nix # (1)!\n</code></pre> <p>You can verify that this works by just typing the following:</p> <pre><code>nix run enix#geth -- --version\n</code></pre> <p>After a while (the first invocation, the command will take a little bit), the current version of geth should appear!</p> <ol> <li>You can choose another alias instead of <code>enix</code>. We named it <code>enix</code> because it's short and sweet!</li> </ol> <ol> <li> <p>Thanks to the Nix/NixOS documentation team.\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2022-2023 Ethereum.nix contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a bug","text":"<p>TBW</p>"},{"location":"contributing/reporting-a-change/","title":"Reporting a change","text":"<p>TBW</p>"},{"location":"contributing/reporting-a-docs-issue/","title":"Reporting a docs issue","text":"<p>TBW</p>"},{"location":"nixos/backup-and-restore/","title":"Backup and restore","text":"<p>The following service modules support backups:</p> <ul> <li>Geth</li> <li>Prysm Beacon</li> </ul> <p>Backup and restore functionality is implemented with Restic.</p>"},{"location":"nixos/backup-and-restore/#storage-providers","title":"Storage providers","text":"<p>At the time of writing Restic supports the following storage backends:</p> <ul> <li>Local</li> <li>SFTP</li> <li>REST Server</li> <li>Amazon S3</li> <li>Minio Server</li> <li>Wasabi</li> <li>Alibaba Cloud Object Storage System</li> <li>OpenStack Swift</li> <li>Backblaze B3</li> <li>Microsoft Azure Blob Storage</li> <li>Google Cloud Storage</li> <li>Other services vis RClone</li> </ul>"},{"location":"nixos/backup-and-restore/#configuring-backups","title":"Configuring backups","text":"<p>Backup options are set inside the <code>backup</code> section of supporting modules.</p> backup.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\n...\nbackup = {\nenable = true;\nschedule = \"0/1:00:00\";\nrestic = {\nrepository = \"s3:http://dione:9000/geth-sepolia\";\npasswordFile = sops.secrets.restic_password.path;\nenvironmentFile = sops.secrets.restic_env.path;\n};\n};\n};\n}\n</code></pre> <p>By default, backups are scheduled daily. This can be modified through the schedule option which follows the same format as systemd.time.</p> <p>To access a Restic repository, a password (also called a key) must be specified. This can be done via <code>restic.passwordFile</code>.</p> <p>And since Restic can be configured with a wide variety of storage providers, an environment file can be provided to accommodate their configuration. When using an Amazon S3 backend for example the environment file might look like this:</p> aws.env<pre><code>AWS_DEFAULT_REGION=eu-west-1\nAWS_ACCESS_KEY_ID=my_access_key\nAWS_SECRET_ACCESS_KEY=my_secret_key\n</code></pre> <p>For a detailed list of options please see here.</p>"},{"location":"nixos/backup-and-restore/#systemd-services","title":"Systemd services","text":"<p>When backups are enabled several new Systemd services and timers will be introduced to facilitate the backup process.</p> <p>For an instance of Geth named <code>sepolia</code> for example, the following services will be added:</p> <ul> <li><code>geth-sepolia-metadata.service</code> which captures metadata such as chain height and persists it in the state directory.</li> <li><code>geth-sepolia-metadata.timer</code> which triggers the metadata service every 10 seconds by default. This interval is configurable via metadata.interval.</li> <li><code>geth-sepolia-backup.service</code> which is responsible for stopping <code>geth-sepolia.service</code>, backing up its state directory, and restarting it.</li> <li><code>geth-sepolia-backup.timer</code> which triggers the backup service once daily by default. This schedule is configurable via backup.schedule.</li> </ul>"},{"location":"nixos/backup-and-restore/#restoring-from-backup","title":"Restoring from backup","text":"<p>Restore options are set inside the <code>restore</code> section of supporting modules and share many of the same config options as backups.</p> restore.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\n...\nrestore = {\nenable = true;\nsnapshot = \"latest\";\nrestic = {\nrepository = \"s3:http://dione:9000/geth-sepolia\";\npasswordFile = sops.secrets.restic_password.path;\nenvironmentFile = sops.secrets.restic_env.path;\n};\n};\n};\n}\n</code></pre> <p>The one key difference is the <code>snapshot</code> option which details which snapshot to restore from. This can be <code>latest</code> as seen in the example above, or a specific snapshot id as listed by running <code>restic snapshots</code>:</p> <pre><code>\u276f restic snapshots -c | head\nID        Time                 Host    Tags\n-------------------------------------------------------------------------------------------------------------------\n5e2006e9  2023-03-22 07:00:07  phoebe  height:3139753\n                                       number:0x2fe8a9\n                                       stateRoot:0x1be15cbc48fbd1ddb2fee1332f5fd6eacca60a737b4e87874c82be32810b19a5\n                                       hash:0x04a53f7cc92888de4ea743419855abdfff4ba84454db211846d984609578b265\n                                       name:geth-sepolia\nbdf903fc  2023-03-22 08:00:18  phoebe  height:3140008\n                                       number:0x2fe9a8\n                                       stateRoot:0xac1fd086f4e5afe152afd110f67ce86a5787895ca75c3fffa516229fc10ec9b2\n                                       hash:0x330594bc56d97b30c9794f33c692f32f3e29a6de1acb495cc4e66b0a437dc4c3\n                                       name:geth-sepolia\ne83e3f49  2023-03-22 09:00:17  phoebe  height:3140256\n                                       number:0x2feaa0\n                                       stateRoot:0x0a82d296b70638063187208707681d8976769594e65cd823da7429e215cce2a7\n                                       hash:0x6b39cfca2375b0cfb11e59c9f159e7a19108aa25cfbf4a88de53a9c1e089e233\n                                       name:geth-sepolia\n</code></pre> <p>Note: restoring from backup will only be attempted if the state directory for the service in question is empty. The presence of any files will cause the restoration attempt to be aborted.</p> <p>This means it is safe to leave the restore config in place as it only has an effect when initialising a fresh instance.</p>"},{"location":"nixos/installation/","title":"Installation","text":"<p>Below you'll find several examples of how to import Ethereum.nix. Choose appropriately depending on if you're using nix with flakes enabled or not.</p>"},{"location":"nixos/installation/#with-flakes-no-overlays","title":"With flakes without using overlays recommended","text":"<code>flake.nix</code> <pre><code>{\ninputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/23.11\";\nethereum-nix = {\nurl = \"github:nix-community/ethereum.nix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n};\n};\noutputs = inputs @ { self, ethereum-nix, nixpkgs, ... }: let\nsystem = \"x86_64-linux\";\nin {\n    nixosConfigurations.my-system = nixpkgs.lib.nixosSystem {\ninherit system;\npkgs = nixpkgs.legacyPackages.${system};\nmodules = [\n# optional: add nixos modules via the default nixosModule\n        ethereum-nix.nixosModules.default\n\n({pkgs, system, ...}: {\n          environment.systemPackages = (with ethereum-nix.packages.${system}; [\n            teku\n            lighthouse\n            # ...\n]);\n})\n];\n};\n};\n}\n</code></pre>"},{"location":"nixos/installation/#with-flakes-overlays","title":"With flakes using overlays","text":"<code>flake.nix</code> <pre><code>{\ninputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/23.11\";\nethereum-nix = {\nurl = \"github:nix-community/ethereum.nix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n};\n};\noutputs = inputs @ { self, ethereum-nix, nixpkgs, ... }: let\nsystem = \"x86_64-linux\";\npkgs = import inputs.nixpkgs {\ninherit system;\noverlays = [\n# add packages via the default overlay\n        ethereum-nix.overlays.default\n      ];\n};\nin {\n    nixosConfigurations.my-system = nixpkgs.lib.nixosSystem {\ninherit system pkgs;\nmodules = [\n# optional: add nixos modules via the default nixosModule\n        ethereum-nix.nixosModules.default\n      ];\n};\n};\n}\n</code></pre>"},{"location":"nixos/installation/#with-pure-nix","title":"With pure nix","text":"<code>default.nix</code> <pre><code>{\n  ethereum-nix ? import (fetchTarball \"https://github.com/nix-community/ethereum.nix/archive/main.tar.gz\"),\n  system ? \"x86_64-linux\",\n  pkgs ?\nimport &lt;nixpkgs&gt; { # (1)!\ninherit system;\noverlays = [\n# add packages via the default overlay\n        ethereum-nix.overlays.default\n      ];\n},\n}: {\nmy-machine = pkgs.lib.nixosSystem {\ninherit system pkgs;\nmodules = [\n# optional: add nixos modules via the default nixosModule\n      ethereum-nix.nixosModules.default\n    ];\n};\n}\n</code></pre> <ol> <li>You must ensure that your <code>NIX_PATH</code> has <code>nixpkgs</code> pointing to a version that contains nixos modules (e.g. <code>nixpkgs=https://github.com/NixOS/nixpkgs/archive/nixos-23.11.tar.gz</code>)</li> </ol>"},{"location":"nixos/installation/#with-niv","title":"With niv","text":"<p>First, add Ethereum.nix to your <code>sources.json</code>:</p> <pre><code>niv add nix-community/ethereum.nix\n</code></pre> <p>And just import it like below:</p> <pre><code>{system ? builtins.currentSystem}: let\nsources = import ./sources.nix;\nethereum-nix = import sources.\"ethereum.nix\";\npkgs = import sources.nixpkgs {\ninherit system;\noverlays = [\n      ethereum-nix.overlays.default\n    ];\n};\nin\nmy-machine = pkgs.lib.nixosSystem {\ninherit system pkgs;\nmodules = [\n# optional: add nixos modules via the default nixosModule\n      ethereum-nix.nixosModules.default\n    ];\n}\n</code></pre>"},{"location":"nixos/restore-from-backup/","title":"Restoring from a backup","text":"<p>The following service modules support restoring from backups:</p> <ul> <li>Geth</li> <li>Prysm Beacon</li> </ul> <p>For an overview of how to configure backups please see here</p>"},{"location":"nixos/restore-from-backup/#basic-configuration","title":"Basic configuration","text":"<p>Restore options are set inside the <code>restore</code> section of supporting modules.</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\n...\nrestore = {\nenable = true;\nsnapshot = \"3090378\";\nborg = {\nrepo = \"ssh://borg@backup.server/data/borgbackup/ethereum/geth-sepolia\";\nkeyPath = \"/root/ed25519\";\nunencryptedRepoAccess = true;\n};\n};\n};\n}\n</code></pre>"},{"location":"nixos/restore-from-backup/#borg-backup","title":"Borg Backup","text":""},{"location":"nixos/restore-from-backup/#host-key-checking","title":"Host key checking","text":"<p>Borg Backup uses ssh when connecting to a remote repository and as such requires an ssh private key. This key path can be provided via the keyPath option.</p> <p>When connecting to a backup host for the first time a restoration may fail if the provided host key has not been added to the remote machine's known host list.</p> <p>For testing and development purposes this check can be disabled via the strictHostKeyChecking option.</p> <p>For production setups it is recommended to update the remote server's known host list first before any backups are scheduled.</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\n...\nrestore = {\nenable = true;\nsnapshot = \"3090378\";\nborg = {\nrepo = \"ssh://borg@dione/data/borgbackup/ethereum/geth-sepolia\";\nkeyPath = \"/root/ed25519\";\nstrictHostKeyChecking = false;\n};\n};\n};\n}\n</code></pre>"},{"location":"nixos/restore-from-backup/#repository-encryption","title":"Repository encryption","text":"<p>There are several encryption schemes available for securing backup repositories.</p> <p>**Note: ** The encryption mode can only be configured when creating a new repository - you can neither configure it on a per-archive basis nor change the encryption mode of an existing repository.</p> <p>For an overview of the encryption schemes available please refer to the borg backup official docs.</p> <p>Suitable corresponding NixOS options for configuring encryption are available.</p>"},{"location":"nixos/running-geth/","title":"Running Geth","text":"<p>One or more Geth services can be configured with the <code>services.ethereum.geth</code> prefix.</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\nenable = true;\npackage = pkgs.geth;\nopenFirewall = true;\nargs = {\nsyncmode = \"full\";\nnetwork = \"sepolia\";\nhttp = {\nenable = true;\naddr = \"0.0.0.0\";\nvhosts = [\"localhost\" \"phoebe\"];\napi = [\"net\" \"web3\" \"eth\"];\n};\n      authrpc.jwtsecret = sops.secrets.geth_jwt_secret.path;\n};\nextraArgs = [\n\"--bootnodes\"\n\"enode://8ae4559db1b1e160be8cc46018d7db123ed6d03fbbfe481da5ec05f71f0aa4d5f4b02ad059127096aa994568706a0d02933984083b87c5e1e3de2b7692444d37@35.161.233.158:46855,enode://d0b3b290422f35ec3e68356f3a4cdf9c661f71a868110670e31441a5021d7abd0440ae8dfb9360aafdd0198f177863361e3a7a7eb5e1a3e26575bf1ac3ef4ab3@162.19.136.65:48264,enode://d64624bda3cdb65d542c90757a4a661cfe9dddf8328bdb1ea97a8d70fad287c360f0101c492d8fd6ab30d79160a3bf148cacfd68f5d2e47eab0b709516419304@51.195.63.10:30040,enode://c7df835939e027325c6bba926220fae5912a33c83d96b3eef8ef445c98083f3191788581c9a0e8f74cadb0b13229b847f5c1ebd315b22bcf11faf6468020eb48@54.163.51.157:30303,enode://da0609bad3afcab9b93175a41a2d621d07aa7ff6c134a00792d4541f0ce8d30d8f3c51bb37a47573508a0bf18865b04066af2a661edf1d3a3d8d133fc1031aa0@88.151.101.14:45192,enode://7a4534d392c59369eae6befa56ac670476d9edc16597cf53c92bbefa6e741b6b0b9e6822cab12afb09123e03ca1131026fbef145adec429fe2e50182dfb650a5@94.130.18.108:31312,enode://db6fa13b63a885440de581ee3fc8df9c6a590326b39fc5ccba7991707ee0cebac306211f7eca5270a350201a3132511f2338481edd81f3dc819c2a1c60419cf2@65.21.89.157:30303,enode://fcf03e9404cace34c60e4eed374ef9a779471014319b3346352fbc2f992a399af6517486e8e65a4ab55f4645fe55420bbea1cddc13a4af4df63b0f731915c6a6@13.125.238.49:46173,enode://8b973816278fdd56966709e4794c7ccce1f256eaa9165a6b013b991a9bdf3886a8f2d23af50ee723a5614a9fe9d197252b803b4455a87ab2468e128f7b06e0ca@172.104.107.145:30303,enode://5a1fb15f826a213d3ef4adb9be47ab58b2240ea05df0d760a244f04762b0847dcb08276b1284f726c22eea30fce0c601cf121b81bac0c151f1b3b4ad00d1482a@34.159.55.147:51262,enode://560928dd14819f88113586726e452b16bbc694ed4144ddadd6290053e7f3fc66bfad13add6889f7d8f37e0c21ccbb6948eb8899c8b30743f4b45a3081f1efed8@34.138.254.5:29888,enode://69a13b575b8c5278431409e9f7db36e7218667ae286bfb65a72dfec9201b2c5bbbe2797a1babbdf17a7bf7ca68fa3fbe1554612637eb1b2425fa975e1bccb54c@35.223.41.3:30303,enode://66158b31eecff939f220b291d2b448edbfe94f1d4c992d9395b5d476e55e54b5abd11d3ee44daf1e18ee27b910ef99cdf6f19775eb4820ebe4f77d7aa948e3b6@51.195.63.10:55198,enode://bf94acbd51170bf075cacb9f149b21ff46354d659ab434a0d40688f776e1e1556bc62be2dc2867ba513844268c0dc8240099a6b60efe1713fbc25da7fdeb6ff1@3.82.105.139:30303,enode://41329e5ceb51cdddbe6a475db00b682505768b71ff8ee37d2d3500ca1b78918f9fad57d6006dd9f79cd418437dbcf87ec2fd58d60710f925cb17da05a51197cf@65.21.34.60:30303\"\n];\n};\n  services.ethereum.geth.goerli = {\nenable = true;\n...\n};\n}\n</code></pre> <p>Note: It is recommended to use an attribute name that matches the network that Geth is configured for.</p>"},{"location":"nixos/running-geth/#configuration","title":"Configuration","text":"<p>Many of Geth's process arguments have been mapped to NixOS types and can be provided via the <code>args</code> section of the config. For a detailed list please refer to the NixOS Options reference.</p> <p>Additional arguments can be provided in a list directly to the Geth process via the <code>extraArgs</code> attribute as shown above.</p>"},{"location":"nixos/running-geth/#systemd-service","title":"Systemd service","text":"<p>For each instance that is configured a corresponding Systemd service is created. The service name follows a convention of <code>geth-${name}.service</code>.</p> Config Name Service name <code>services.ethereum.geth.sepolia</code> sepolia <code>geth-sepolia.service</code> <code>services.ethereum.geth.goerli</code> goerli <code>geth-goerli.service</code> <code>services.ethereum.geth.mainnet</code> mainnet <code>geth-mainnet.service</code> <p>The service that is created can then be introspected and managed via the standard Systemd toolset.</p> Action Command Status <code>systemctl status geth-sepolia.service</code> Stop <code>systemctl stop geth-sepolia.service</code> Start <code>systemctl start geth-sepolia.service</code> Restart <code>systemctl restart geth-sepolia.service</code> Logs <code>journalctl -xefu geth-sepolia.service</code>"},{"location":"nixos/running-geth/#using-a-geth-fork","title":"Using a Geth fork","text":"<p>A different version of Geth can be configured via the package option.</p> <p>To configure Geth Sealer for example:</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.geth.sepolia = {\nenable = true;\npackage = pkgs.geth-sealer;\n...\n};\n}\n</code></pre>"},{"location":"nixos/running-geth/#opening-ports","title":"Opening ports","text":"<p>By default, openFirewall is set to <code>false</code>. If set to <code>true</code>, firewall rules are added which will expose the following ports:</p> Protocol Config Default value TCP, UDP port 30303 TCP authrpc.port 8551 TCP http.port 8545 TCP ws.port 8546 TCP metrics.port 6060 <p>Note: it is important when running multiple instances of Geth on the same machine that you ensure they are configured with different ports.</p>"},{"location":"nixos/running-lighthouse-beacon/","title":"Running Lighthouse Beacon","text":"<p>One or more Lighthouse Beacon services can be configured with the <code>services.ethereum.lighthouse-beacon</code> prefix.</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.lighthouse-beacon.sepolia = {\nenable = true;\nopenFirewall = true;\nargs = {\nnetwork = \"sepolia\"; # (Optional) defaults to beacon name\nexecution-jwt = secrets.lighthouse_jwt_secret.path;\ncheckpoint-sync-url = \"https://sepolia.checkpoint-sync.ethdevops.io\";\ngenesis-state-url = \"https://sepolia.checkpoint-sync.ethdevops.io\";\n};\nhttp-address = \"0.0.0.0\";\n};\n  services.ethereum.lighthouse-beacon.goerli = {\nenable = true;\n...\n};\n}\n</code></pre> <p>Note: It is recommended to use an attribute name that matches the network that Lighthouse Beacon is configured for.</p>"},{"location":"nixos/running-lighthouse-beacon/#configuration","title":"Configuration","text":"<p>Many of Lighthouse Beacon's process arguments have been mapped to NixOS types and can be provided via the <code>args</code> section of the config. For a detailed list please refer to the NixOS Options reference.</p> <p>Additional arguments can be provided in a list directly to the Lighthouse Beacon process via the <code>extraArgs</code> attribute as shown above.</p>"},{"location":"nixos/running-lighthouse-beacon/#systemd-service","title":"Systemd service","text":"<p>For each instance that is configured a corresponding Systemd service is created. The service name follows a convention of <code>lighthouse-beacon-${name}.service</code>.</p> Config Name Service name <code>services.ethereum.lighthouse-beacon.sepolia</code> sepolia <code>lighthouse-beacon-sepolia.service</code> <code>services.ethereum.lighthouse-beacon.goerli</code> goerli <code>lighthouse-beacon-goerli.service</code> <code>services.ethereum.lighthouse-beacon.mainnet</code> mainnet <code>lighthouse-beacon-mainnet.service</code> <p>The service that is created can then be introspected and managed via the standard Systemd toolset.</p> Action Command Status <code>systemctl status lighthouse-beacon-sepolia.service</code> Stop <code>systemctl stop lighthouse-beacon-sepolia.service</code> Start <code>systemctl start lighthouse-beacon-sepolia.service</code> Restart <code>systemctl restart lighthouse-beacon-sepolia.service</code> Logs <code>journalctl -xefu lighthouse-beacon-sepolia.service</code>"},{"location":"nixos/running-lighthouse-beacon/#using-a-lighthouse-beacon-fork","title":"Using a Lighthouse Beacon fork","text":"<p>A different version of Lighthouse Beacon can be configured via the package option.</p> <p>To configure a custom fork for example:</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.lighthouse-beacon.sepolia = {\nenable = true;\npackage = pkgs.my-lighthouse-beacon;\n...\n};\n}\n</code></pre>"},{"location":"nixos/running-lighthouse-beacon/#opening-ports","title":"Opening ports","text":"<p>By default, openFirewall is set to <code>false</code>. If set to <code>true</code> firewall rules are added which will expose the following ports:</p> Protocol Config Default value UDP discovery-port 9000 UDP/TCP quic-port 9001 TCP http-port 5052 <p>Note: it is important when running multiple instances of Lighthouse Beacon on the same machine that you ensure they are configured with different ports.</p>"},{"location":"nixos/running-prysm-beacon/","title":"Running Prysm Beacon","text":"<p>One or more Prysm Beacon services can be configured with the <code>services.ethereum.prysm-beacon</code> prefix.</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.prysm-beacon.sepolia = {\nenable = true;\nopenFirewall = true;\nargs = {\nnetwork = \"sepolia\";\njwt-secret = secrets.prysm_jwt_secret.path;\ncheckpoint-sync-url = \"https://sepolia.checkpoint-sync.ethdevops.io\";\ngenesis-beacon-api-url = \"https://sepolia.checkpoint-sync.ethdevops.io\";\n};\nextraArgs = [\n\"--rpc-host=0.0.0.0\"\n\"--monitoring-host=0.0.0.0\"\n];\n};\n  services.ethereum.prysm-beacon.goerli = {\nenable = true;\n...\n};\n}\n</code></pre> <p>Note: It is recommended to use an attribute name that matches the network that Prysm Beacon is configured for.</p>"},{"location":"nixos/running-prysm-beacon/#configuration","title":"Configuration","text":"<p>Many of Prysm Beacon's process arguments have been mapped to NixOS types and can be provided via the <code>args</code> section of the config. For a detailed list please refer to the NixOS Options reference.</p> <p>Additional arguments can be provided in a list directly to the Prysm Beacon process via the <code>extraArgs</code> attribute as shown above.</p>"},{"location":"nixos/running-prysm-beacon/#systemd-service","title":"Systemd service","text":"<p>For each instance that is configured a corresponding Systemd service is created. The service name follows a convention of <code>prysm-beacon-${name}.service</code>.</p> Config Name Service name <code>services.ethereum.prysm-beacon.sepolia</code> sepolia <code>prysm-beacon-sepolia.service</code> <code>services.ethereum.prysm-beacon.goerli</code> goerli <code>prysm-beacon-goerli.service</code> <code>services.ethereum.prysm-beacon.mainnet</code> mainnet <code>prysm-beacon-mainnet.service</code> <p>The service that is created can then be introspected and managed via the standard Systemd toolset.</p> Action Command Status <code>systemctl status prysm-beacon-sepolia.service</code> Stop <code>systemctl stop prysm-beacon-sepolia.service</code> Start <code>systemctl start prysm-beacon-sepolia.service</code> Restart <code>systemctl restart prysm-beacon-sepolia.service</code> Logs <code>journalctl -xefu prysm-beacon-sepolia.service</code>"},{"location":"nixos/running-prysm-beacon/#using-a-prysm-beacon-fork","title":"Using a Prysm Beacon fork","text":"<p>A different version of Prysm Beacon can be configured via the package option.</p> <p>To configure a custom fork for example:</p> server.nix<pre><code>{ pkgs, ...}: {\n  services.ethereum.prysm-beacon.sepolia = {\nenable = true;\npackage = pkgs.my-prysm-beacon;\n...\n};\n}\n</code></pre>"},{"location":"nixos/running-prysm-beacon/#opening-ports","title":"Opening ports","text":"<p>By default, openFirewall is set to <code>false</code>. If set to <code>true</code> firewall rules are added which will expose the following ports:</p> Protocol Config Default value UDP p2p-udp-port 12000 TCP p2p-tcp-port 13000 TCP grpc-gateway-port 3500 TCP monitoring-port 8080 TCP pprofport 8080 <p>Note: it is important when running multiple instances of Prysm Beacon on the same machine that you ensure they are configured with different ports.</p>"}]}